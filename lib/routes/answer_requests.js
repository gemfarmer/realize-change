// Generated by CoffeeScript 1.6.3
(function() {
  var GlobalAnswer, mongoose, passport, user;

  mongoose = require('mongoose');

  GlobalAnswer = require('./../models/answers');

  user = require('./../models/user');

  passport = require('passport');

  (function() {
    var sb;
    sb = function(f) {
      var i, o;
      i = this.length;
      while (i) {
        o = this[--i];
        this[i] = [].concat(f.call(o, o, i), o);
      }
      this.sort(function(a, b) {
        var len;
        i = 0;
        len = a.length;
        while (i < len) {
          if (a[i] !== b[i]) {
            return (a[i] < b[i] ? -1 : 1);
          }
          ++i;
        }
        return 0;
      });
      i = this.length;
      while (i) {
        this[--i] = this[i][this[i].length - 1];
      }
      return this;
    };
    if (typeof Object.defineProperty === "function") {
      try {
        Object.defineProperty(Array.prototype, "sortBy", {
          value: sb
        });
      } catch (_error) {}
    }
    if (!Array.prototype.sortBy) {
      return Array.prototype.sortBy = sb;
    }
  })();

  exports.sendanswer = function(req, res) {
    var newGlobalAnswer, newUser;
    console.log("answerquery", req.query);
    newGlobalAnswer = new GlobalAnswer();
    newGlobalAnswer.answerFuture = req.query.answerFuture;
    newGlobalAnswer.answerGoals = req.query.answerGoals;
    newGlobalAnswer.save(function(err) {
      if (err) {
        throw err;
      }
    });
    if (req.user) {
      return user.find({
        _id: "" + req.user._id
      }, function(err, userToUpdate) {
        userToUpdate[0].update({
          answers: {
            answerFuture: req.query.answerFuture,
            answerGoals: req.query.answerGoals
          }
        }, function(err) {
          if (err) {
            throw err;
          }
        });
        return res.send({
          success: "success"
        });
      });
    } else {
      console.log("else");
      newUser = new user();
      newUser.ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
      newUser.answers = {
        answerFuture: req.query.answerFuture,
        answerGoals: req.query.answerGoals
      };
      console.log(newUser);
      return newUser.save(function(err) {
        if (err) {
          throw err;
        }
        console.log("New user, " + newUser.name + ", was created", newUser.answers);
        return res.send({
          success: "success"
        });
      });
    }
  };

  exports.getanswers = function(req, res) {
    var randomAnswer, sortAsc, sortDesc;
    console.log("query", req.query);
    sortAsc = function() {
      console.log('asc');
      return GlobalAnswer.find({}, function(err, results) {
        var sortedResults;
        sortedResults = results.sortBy(function() {
          return [this.votes];
        });
        console.log('sorted', sortedResults);
        return res.send({
          answers: sortedResults
        });
      });
    };
    sortDesc = function() {
      console.log('desc');
      return GlobalAnswer.find({}, function(err, results) {
        var sortedResults;
        sortedResults = results.sortBy(function() {
          return [-this.votes];
        });
        console.log('sorted', sortedResults);
        return res.send({
          answers: sortedResults
        });
      });
    };
    randomAnswer = function() {
      var randOne, randTwo;
      randOne = 0;
      randTwo = 0;
      GlobalAnswer.count({}, function(err, num) {
        var secondRandom;
        console.log("err", err);
        randOne = Math.floor(Math.random() * num);
        console.log("first", randOne);
        secondRandom = function() {
          var output;
          output = Math.floor(Math.random() * num);
          console.log("second", output);
          if (output === randOne) {
            return secondRandom();
          } else {
            return output;
          }
        };
        return randTwo = secondRandom();
      });
      return GlobalAnswer.find({}, function(err, choice) {
        return res.send({
          answers: [choice[randOne], choice[randTwo]],
          filterNone: true
        });
      });
    };
    if (req.query.randomize === 'true') {
      console.log("true");
      return randomAnswer();
    } else if (req.query.asc === 'true') {
      return sortAsc();
    } else if (req.query.desc === 'true') {
      return sortDesc();
    } else if (req.query.future === 'true') {
      console.log('all dreams');
      return GlobalAnswer.find({}, function(err, answers) {
        var answersToSend, arrayLength, i, more;
        console.log("err:", err);
        console.log("answer", answers);
        answersToSend = [];
        i = 0;
        more = true;
        arrayLength = req.query.dreamsToShow;
        if (answers.length < arrayLength) {
          arrayLength = answers.length;
          more = false;
        }
        while (i < arrayLength) {
          answersToSend.push({
            answerFuture: answers[i].answerFuture,
            filterFuture: "future",
            more: more
          });
          i++;
        }
        return res.send({
          answers: answersToSend.reverse()
        });
      });
    } else if (req.query.goals === 'true') {
      console.log('all dreams');
      return GlobalAnswer.find({}, function(err, answers) {
        var answer, answersToSend, _i, _len;
        console.log("err:", err);
        console.log("answer", answers);
        answersToSend = [];
        for (_i = 0, _len = answers.length; _i < _len; _i++) {
          answer = answers[_i];
          answersToSend.push({
            answerGoals: answer.answerGoals,
            filterGoals: "goals"
          });
        }
        return res.send({
          answers: answersToSend.reverse()
        });
      });
    } else {
      return GlobalAnswer.find({}, function(err, answers) {
        var answer, answersToSend, _i, _len;
        console.log("err:", err);
        console.log("answer", answers);
        answersToSend = [];
        for (_i = 0, _len = answers.length; _i < _len; _i++) {
          answer = answers[_i];
          answersToSend.push({
            answerGoals: answer.answerGoals,
            answerFuture: answer.answerFuture,
            votes: answer.votes,
            filterNone: "none"
          });
        }
        return res.send({
          answers: answersToSend.reverse()
        });
      });
    }
  };

}).call(this);
